



# 八皇后问题.md

八皇后问题是一个很经典的问题了。

    在一个8*8的棋盘中，放置8个皇后，使得她们互相不能攻击到。
    也就是在每个皇后所在的横排竖排和斜排都不能再出现皇后。
    考虑一共有多少种情况。
    
在网上稍微查一下就能知道这个问题有许多种解法，

这里写一下自己的解题思路和采用的方法。

首先将问题分解细化，很容易想的方法就是一个一个尝试。

首先放一个棋子，再放第二个棋子，检查是否满足条件，

若满足再放第三个棋子，以此类推。

这样就会发现其实过程是一直再重复的，

而对于需要重复执行的内容比较好的方法就是构建函数。

因此这里需要准备的函数就是放棋子和检查是否满足条件。

于是先确定了两个函数`chess()`和`check()`。

而且个人的思考中检查这个步骤是在放棋子之前进行的，

于是认为将`check()`函数使用在`chess()`函数中会使得函数内容更为压缩精简。

另外要做的课题要求将每种情况都打印出来，而不是单纯的计数。

因此又添加了一个输出函数`print()`。

考虑到输出内容是每一次全部满足之后进行输出，

因此需要同步到`chess()`函数中进行。

这样的话main函数中就十分的简单，

只需要执行`chess()`函数就可以了。

另外对皇后位置的保存是根据课题中给的思路，

因为皇后是不能同排的，

因此可以将其位置保存在一个一维数组中，

这样数组的脚标就代表第几行，

数组的内容代表第几列。

```c
int main( void )
{
	int x[ N ] = { 0 };
	
	chess( x, 0 ); //0からやる
	
	printf( "合計は%d個\n", count );
	
	return 0;
}
```

然后开始写函数，

首先写的是`check()`函数，

因为这个函数是我在思考时就认为最简单的函数，

确认是否在横竖排非常容易，

首先通过数组保存首先就排出了同行的情况。

再通过for循环排除同列的情况以及斜排的情况。

仔细观察在同一斜排的特征就会发现其二者差的绝对值与其行数的差的绝对值相同，

因此很容易写出了`check()`函数。

```c
int check( int x[], int n ) //位置をチェックする
{
	int i;
	
	//列と対角線にクイーンがあるかどうかをチェックする
	for( i = 0; i < n; i++ )
		if( x[ i ] == x[ n ] || abs( x[ i ] - x[ n ] ) == ( n - i ) ) return 1;
	
	return 0;
}
```

接下来写的是`chess()`函数，

思路就是让棋子一行一行的尝试，

每次放下后进行检查，如果检查ok就放下一行，

如果放到最后一行就进行打印。

于是也很快写出。

```c
void chess( int x[], int n )
{
	int i;
	
	for( i = 0; i < N; i++ )
	{       
		x[ n ] = i; //クイーンを移動する
		if( check( x, n ) == 0 )
		{           
			if( n == N - 1 ) print( x ); //最後だったら、プリントする
			else chess( x, n + 1 ); //次に続き
		}
	}
}
```

最后写的是`print()`函数，

本来应该很简单的函数却用了最长时间来写。

因为一开始一直没有理解好一维数组所表示的内容，

于是在什么情况下进行打印什么情况下输出空数据有些迷惑。

说起来在分析问题打代码的时候，

真的十分推荐在纸上进行思考，

因为大脑虽然可以思考很抽象的东西，

但是思考的内容呈现的不直观，还容易忘记。

在纸上写好的东西有的时候就很容易帮助你突然想通一些问题。

比如说输出函数，

本来很简单的问题，但是却有点抽象，

我坐在电脑前想了好久，

最后拿笔画了画很快就想到了思路。

首先就是一个二重循环，第一重循环走行，第二重走列。

因为数组的内容标识的是第几列是皇后的位置，

因此需要在循环中查询循环的值是否与数组的值相同，

如果相同的话打印皇后，否则打印空白。

代码如下：

```c
void print( int x[] ) //プリントする
{
	int i, j;
	
	for ( i = 0; i < N; i++ )
	{
		for ( j = 0; j < N; j++ )
		{
			if ( x[ i ] == j ) //i行目j列目にクイーンがある
				printf( " | %c", 'q' );
			else
				printf( " | %c", ' ' );
		}
		
		printf( " |\n\n" );
	}
	
	printf( "x[] = " );
	for ( i = 0; i < N; i++ ) printf( "%d ", x[i] );
	
	printf( "\n" );
	printf( "--------------------------------\n" );
	
	count++;
}
```

下面是全代码，输出内容是四皇后问题，

在最开始使进行了声明，需要变化只需要更改定义的数字。

```c
#include <stdio.h>
#include <stdlib.h>

#define N 4

int count = 0;
void print( int x[] );
int check( int x[], int n );
void chess( int x[], int n );

int main( void )
{
	int x[ N ] = { 0 };
	
	chess( x, 0 ); //0からやる
	
	printf( "合計は%d個\n", count );
	
	return 0;
}

void print( int x[] ) //プリントする
{
	int i, j;
	
	for ( i = 0; i < N; i++ )
	{
		for ( j = 0; j < N; j++ )
		{
			if ( x[ i ] == j ) //i行目j列目にクイーンがある
				printf( " | %c", 'q' );
			else
				printf( " | %c", ' ' );
		}
		
		printf( " |\n\n" );
	}
	
	printf( "x[] = " );
	for ( i = 0; i < N; i++ ) printf( "%d ", x[i] );
	
	printf( "\n" );
	printf( "--------------------------------\n" );
	
	count++;
}

int check( int x[], int n ) //位置をチェックする
{
	int i;
	
	//行と対角線にクイーンがあるかどうかをチェックする
	for( i = 0; i < n; i++ )
		if( x[ i ] == x[ n ] || abs( x[ i ] - x[ n ] ) == ( n - i ) ) return 1;
	
	return 0;
}

void chess( int x[], int n )
{
	int i;
	
	for( i = 0; i < N; i++ )
	{       
		x[ n ] = i; //クイーンを移動する
		if( check( x, n ) == 0 )
		{           
			if( n == N - 1 ) print( x ); //最後だったら、プリントする
			else chess( x, n + 1 ); //次に続き
		}
	}
}
```

执行效果如下：
```
 |   | q |   |   |

 |   |   |   | q |

 | q |   |   |   |

 |   |   | q |   |

x[] = 1 3 0 2
--------------------------------
 |   |   | q |   |

 | q |   |   |   |

 |   |   |   | q |

 |   | q |   |   |

x[] = 2 0 3 1
--------------------------------
合計は2個
```




















